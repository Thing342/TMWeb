//
// Travel Mapping (TM) Data Viewer-related Javascript functions
// formerly for Clinched Highway Mapping (CHM) data
//
// Load and view data files related to TM-related academic data sets.
//
// Renamed as tmjsfuncs.js as part of the Travel Mapping project
//
// Primary author: Jim Teresco, Siena College, The College of Saint Rose
// Additional authors: Razie Fathi, Arjol Pengu, Maria Bamundo, Clarice Tarbay
//
// Portions of this code developed based on examples from 
// http://cmap.m-plex.com/tools/wptedit/wptedit.html
// http://www.alecjacobson.com/weblog/?p=1645
//
// Modification History (pre-GitHub):
//
// 2011-06-20 JDT  Initial implementation
// 2011-06-21 JDT  Added .gra support and checkbox for hidden marker display
// 2011-06-23 JDT  Added .nmp file support (near-miss points)
// 2011-08-23 JDT  Added .pth file support (path)
// 2011-08-31 JDT  Added tabular graph data display
// 2013-08-14 JDT  Completed conversion to Google Maps API V3
// 2013-08-15 JDT  Added custom icon for intersections
// 2013-12-08 JDT  Fixed to handle DOS-style CRLF in uploaded files
// 2013-12-25 JDT  Click on GRA, PTH point label in table recenters map
// 2014-11-17 JDT  Added .wpl file support (waypoint list)
// 2015-06-10 JDT  Adapted for reading from database entries using PHP
// 2015-06-14 JDT  Clinched segment support
// 2015-06-17 JDT  All highways in region support
// 2015-08-19 JDT  Fixed a few bugs with infowindows
// 2016-05-25 JDT  Consolidated some changes from copies of chmviewerfunc3.js
// 2016-06-27 JDT  Removed code not needed by TM
//

// IMPORTANT: when making any modifications to code here, especially
// the loadmap function, note that it is used by various TM pages,
// where variables are mostly set in code generated by waypoints.js.php,
// but also by HDX, where variables are set in various places in
// hdxjsfuncs.js

// get path to lib directory where some images are found,
// which *might* have been set from an hdx.conf file.
var tmlibdir = "/lib/";
try {
    tmlibdir = tmliburl;
}
catch (e) {
}

// global variable to hold the map, which will be assigned a
// Leaflet L.Map reference
var map;

// many of the following are given values in code generated by
// waypoints.js.php for TM functionality, or by functions in
// hdxjsfuns.js (in EduTools/HighwayDataExaminer) for HDX functionality.

// array of waypoints displayed
var waypoints = new Array();
// array of waypoint indices where route changes for region mapping
var newRouteIndices = new Array();
// tiers of each route included
var routeTier = new Array();
// color code for each route included
var routeColor = new Array();
// system for each route included
var routeSystem = new Array();
// the markers at those waypoints
var markers = new Array();
// the info displayed when markers are clicked
var markerinfo = new Array();
// array of google.maps.LatLng representing the waypoint coordinates
var polypoints = new Array();
// array of connections on map as google.maps.Polyline overlays
var connections = new Array();

// array of graph edges (for graph data, used by HDX, which imports this code) -
// this would be a single list of all graph edges.  When using an adjacency
// list representation, edges would also be in vertex-based adjacency lists
var graphEdges = new Array();
// boolean to determine if graph edges should be generated automatically
var genEdges = false;
// boolean to determine if graph edges are in vertex adjacency lists
var usingAdjacencyLists = false;

// array of segments and clinched for "clinched by traveler" mapping
var segments = new Array();
var clinched = new Array();
// boolean to say if we're doing this
var mapClinched = false;
// traveler name for clinched
var traveler;

// array of objects that define color codes from names in the DB
var colorCodes = new Array();
colorCodes[0] = {name: "blue", unclinched: "rgb(100,100,255)", clinched: "rgb(0,0,220)"};
colorCodes[1] = {name: "brown", unclinched: "rgb(153,152,102)", clinched: "rgb(153,102,0)"};
colorCodes[2] = {name: "red", unclinched: "rgb(255,100,100)", clinched: "rgb(224,0,0)"};
colorCodes[3] = {name: "yellow", unclinched: "rgb(255,216,100)", clinched: "rgb(232,176,0)"};
colorCodes[4] = {name: "teal", unclinched: "rgb(100,200,200)", clinched: "rgb(0,140,160)"};
colorCodes[5] = {name: "green", unclinched: "rgb(100,200,100)", clinched: "rgb(0,224,0)"};
colorCodes[6] = {name: "magenta", unclinched: "rgb(255,100,255)", clinched: "rgb(208,0,208)"};
colorCodes[7] = {name: "lightsalmon", unclinched: "rgb(224,162,162)", clinched: "rgb(240,150,115)"};

// array of custom color codes to be pulled from query string parameter
// "colors="
var customColorCodes = new Array();

/*
var MapnikOptions = {
    alt: "Show Mapnik road map tiles from OpenStreetMap.org",
    getTileUrl: getMapnikTileURL,
    maxZoom: 18,
    minZoom: 0,
    name: "Mapnik",
    opacity: 1,
    tileSize: new google.maps.Size(256, 256)
};

var OpenStreetMapDEOptions = {
    alt: "Show OpenStreetMapDE road map tiles from OpenStreetMap.org",
    getTileUrl: getOpenStreetMapDEURL,
    maxZoom: 18,
    minZoom: 0,
    name: "DE",
    opacity: 1,
    tileSize: new google.maps.Size(256, 256)
};

function getOpenStreetMapDEURL(point, zoom) {
    return 'http://tile.openstreetmap.de/tiles/osmde/' + zoom + '/' +
	point.x + '/' + point.y + '.png';
}

var EsriOptions = {
    alt: "Show Esri road map tiles from OpenStreetMap.org",
    getTileUrl: EsriURL,
    maxZoom: 18,
    minZoom: 0,
    name: "Esri",
    opacity: 1,
    tileSize: new google.maps.Size(256, 256)
};

function EsriURL(point, zoom) {
    
    return 'http://server.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/' +
	zoom + '/' + point.y + '/' + point.x;
}

var OpenStreetMapDEOptions = {
    alt: "Show OpenStreetMapDE road map tiles from OpenStreetMap.org",
    getTileUrl: getOpenStreetMapDEURL,
    maxZoom: 18,
    minZoom: 0,
    name: "DE",
    opacity: 1,
    tileSize: new google.maps.Size(256, 256)
};

function getOpenStreetMapDEURL(point, zoom) {
    
    return 'http://tile.openstreetmap.de/tiles/osmde/' + zoom + '/' +
	point.x + '/' + point.y + '.png';
}

//HERE map tiles
var HEREOptions = {
    alt: "Show wego HERE road map tiles from https://wego.here.com",
    getTileUrl: HEREURL,
    maxZoom: 18,
    minZoom: 0,
    name: "HERE",
    opacity: 1,
    tileSize: new google.maps.Size(256, 256)
};

function HEREURL(point, zoom) {
    
    return 'https://1.base.maps.cit.api.here.com/maptile/2.1/maptile/newest/normal.day/' +
	zoom + '/' + point.x + '/' + point.y +
	'/256/png8?app_id=VX6plk5zCW0wzrNcN64O&app_code=LcZFksQAhfg7rvZvcZ1lqw';
}

function getMapnikTileURL(point, zoom) {
    
    return 'http://tile.openstreetmap.org/' + zoom + '/' + point.x + '/' +
	point.y + '.png';
}

var BlankOptions = {
    alt: "Show a blank background",
    getTileUrl: getBlankURL,
    maxZoom: 18,
    minZoom: 0,
    name: "Blank",
    opacity: 1,
    tileSize: new google.maps.Size(256, 256)
};

function getBlankURL() {
    return tmlibdir + 'empty.gif';
}
*/
var intersectionimage = L.icon({
    iconUrl: '/img/Intersection.png',
    // This marker is 16x16
    iconSize: [16, 16]
});

var oldintersectionimage = L.icon({
    iconUrl: '/img/smallintersection.png',
    // This marker is 16x16
    iconSize: [16, 16]
});

function convertUnit(measurement, fromUnit, toUnit) {
    if (fromUnit === toUnit) return measurement;

    if (fromUnit === 'mi' && toUnit === 'km') {
        return measurement * 1.60934
    }

    if (fromUnit === 'km' && toUnit === 'mi') {
        return measurement / 1.60934
    }
}

function convertAllUnits(fromUnit, toUnit) {
    $('.unit').each(function () {
        let it = $(this);
        let measurement = parseFloat(it.text());
        let conversion = convertUnit(measurement, fromUnit, toUnit);
        it.text(conversion.toFixed(2));
    });

    $('.units-text').each(function () {
        let it = $(this);
        it.text(toUnit);
    });
}

// loadmap constructs and sets up the initial map
function loadmap() {

    // Leaflet map object
    map = L.map('map', {
        renderer: L.canvas()
    });

    map.setView([0, 0], 16);

    var osmUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
    var osmAttrib = 'Map data Â© <a href="https://openstreetmap.org">OpenStreetMap</a> contributors';
    var osm = new L.TileLayer(osmUrl, {minZoom: 3, maxZoom: 18, attribution: osmAttrib});
    var stamenToner = new L.StamenTileLayer("toner");
    var stamenTerrain = new L.StamenTileLayer("terrain");
    map.addLayer(stamenTerrain);
    var layers = {
        "OpenStreetMap": osm,
        "Stamen Toner": stamenToner,
        "Stamen Terrain": stamenTerrain
    };
    var overlays = {};
    L.control.layers(layers, overlays).addTo(map);
}

// construct a new Waypoint object (based on similar function by Tim Reichard)
// now supporting edge adjacency lists
// these sometimes have a field "intersecting" added to them which is
// an array of intersecting Routes (defined below)
function Waypoint(label, lat, lon, elabel, edgeList) {
    this.label = label;
    this.lat = parseFloat(lat).toFixed(6);
    this.lon = parseFloat(lon).toFixed(6);
    this.visible = true;
    if (label.indexOf("+") >= 0) {
        this.visible = false;
    }
    this.elabel = elabel;
    this.edgeList = edgeList;
    return this;
}

// construct a Route object to encapsulate information needed for intersecting
// routes
function Route(root, route, region, banner, abbrev, city) {

    this.root = root;
    this.route = route;
    this.region = region;
    this.banner = banner;
    this.abbrev = abbrev;
    this.city = city;
    return this;
}

// update the map to the current set of waypoints and connections
function updateMap() {
    // remove any existing Polyline connections shown
    for (var i = 0; i < connections.length; i++) {
        connections[i].remove();
    }
    connections = new Array();

    // set up to find bounding box of points we plot
    var minlat = 999;
    var maxlat = -999;
    var minlon = 999;
    var maxlon = -999;

    // remove any markers previously on the map
    for (var i = 0; i < markers.length; i++) {
        markers[i].remove();
    }
    markers = new Array();

    // set variables that determine if all/only visible/no markers
    // should be drawn on the map
    var showHidden = false;
    if (document.getElementById('showHidden') != null) {
        showHidden = document.getElementById('showHidden').checked;
    }
    var showMarkers = true;
    if (document.getElementById('showMarkers') != null) {
        showMarkers = document.getElementById('showMarkers').checked;
    }

    // draw our waypoint markers
    markerinfo = new Array();
    polypoints = new Array();

    for (var i = 0; i < waypoints.length; i++) {
        minlat = Math.min(minlat, waypoints[i].lat);
        maxlat = Math.max(maxlat, waypoints[i].lat);
        minlon = Math.min(minlon, waypoints[i].lon);
        maxlon = Math.max(maxlon, waypoints[i].lon);

        polypoints[i] = [waypoints[i].lat, waypoints[i].lon];

        markerinfo[i] = markerInfo(i, waypoints[i]);
        markers[i] = L.marker(polypoints[i], {
            title: waypoints[i].label,
            icon: intersectionimage
        });
        if (showMarkers && (showHidden || waypoints[i].visible)) {
            addMarker(markers[i], markerinfo[i], i);
        }
    }

    // set our map view according to the bounds we found
    map.fitBounds([[minlat, minlon], [maxlat, maxlon]]);

    // if this is a graph in HDX, we draw edges as connections,
    // otherwise we may be connecting waypoints in order to plot a
    // path
    if (graphEdges.length > 0) {
        for (var i = 0; i < graphEdges.length; i++) {
            var numPoints;
            if (graphEdges[i].via == null) {
                numPoints = 2;
            }
            else {
                numPoints = graphEdges[i].via.length / 2 + 2;
            }
            var edgePoints = new Array(numPoints);
            var v1 = graphEdges[i].v1;
            var v2 = graphEdges[i].v2;
            //	    DBG.write("Adding edge " + i + " from " + v1 + "(" + waypoints[v1].lat + "," + waypoints[v1].lon + ") to " + v2 + "(" + waypoints[v2].lat + "," + waypoints[v2].lon + ")");
            edgePoints[0] = [waypoints[v1].lat, waypoints[v1].lon];
            nextPoint = 1;
            if (graphEdges[i].via != null) {
                for (var j = 0; j < graphEdges[i].via.length; j += 2) {
                    edgePoints[nextPoint] = [graphEdges[i].via[j], graphEdges[i].via[j + 1]];
                    nextPoint++;
                }
            }
            edgePoints[nextPoint] = [waypoints[v2].lat, waypoints[v2].lon];
            color = getGraphEdgeColor(graphEdges[i]);
            connections[i] = L.polyline(edgePoints, {
                color: color,
                weight: 10,
                opacity: 0.4
            }).addTo(map);
            edgeListener(i);
        }
    }
    else if (usingAdjacencyLists) {
        var edgeNum = 0;
        for (var i = 0; i < waypoints.length; i++) {
            for (var j = 0; j < waypoints[i].edgeList.length; j++) {
                var thisEdge = waypoints[i].edgeList[j];
                // avoid double plot by only plotting those with v1 as i
                if (thisEdge.v1 == i) {
                    var numPoints;
                    if (thisEdge.via == null) {
                        numPoints = 2;
                    }
                    else {
                        numPoints = thisEdge.via.length / 2 + 2;
                    }
                    var edgePoints = new Array(numPoints);
                    edgePoints[0] = [waypoints[thisEdge.v1].lat, waypoints[thisEdge.v1].lon];
                    nextPoint = 1;
                    if (thisEdge.via != null) {
                        for (var p = 0; p < thisEdge.via.length; p += 2) {
                            edgePoints[nextPoint] = [thisEdge.via[p], thisEdge.via[p + 1]];
                            nextPoint++;
                        }
                    }
                    edgePoints[nextPoint] = [waypoints[thisEdge.v2].lat, waypoints[thisEdge.v2].lon];

                    color = getGraphEdgeColor(thisEdge);
                    connections[edgeNum] = L.polyline(edgePoints, {
                        color: color,
                        weight: 10,
                        opacity: 0.4
                    }).addTo(map);
                    edgeListener(edgeNum);
                    edgeNum++;
                }
            }
        }
        map.on('zoomend', zoomChange);
        zoomChange();
    }
    // connecting waypoints in order to plot a path
    else if (mapClinched) {
        // clinched vs unclinched segments mapped with different colors
        var nextClinchedCheck = 0;
        var totalMiles = 0.0;
        var clinchedMiles = 0.0;
        var level = map.getZoom();
        var weight = 2;
        if (newRouteIndices.length > 0) {
            // if newRouteIndices is not empty, we're plotting multiple routes
            var nextSegment = 0;
            for (var route = 0; route < newRouteIndices.length; route++) {
                var start = newRouteIndices[route];
                var end;
                if (route == newRouteIndices.length - 1) {
                    end = waypoints.length - 1;
                }
                else {
                    end = newRouteIndices[route + 1] - 1;
                }
                // support for clinch colors from systems.csv
                var unclinchedColor = "rgb(200,200,200)"; //"#cccccc";
                var clinchedColor = "rgb(255,128,128)"; //"#ff8080";
                for (var c = 0; c < colorCodes.length; c++) {
                    if (colorCodes[c].name == routeColor[route]) {
                        unclinchedColor = colorCodes[c].unclinched;
                        clinchedColor = colorCodes[c].clinched;
                    }
                }
                // override with tier or system colors given in query string if they match
                for (var c = 0; c < customColorCodes.length; c++) {
                    if (customColorCodes[c].name == ("tier" + routeTier[route])) {
                        unclinchedColor = customColorCodes[c].unclinched;
                        clinchedColor = customColorCodes[c].clinched;
                    }
                    if (customColorCodes[c].name == routeSystem[route]) {
                        unclinchedColor = customColorCodes[c].unclinched;
                        clinchedColor = customColorCodes[c].clinched;
                    }
                }
                for (var i = start; i < end; i++) {
                    var edgePoints = new Array(2);
                    edgePoints[0] = [waypoints[i].lat, waypoints[i].lon];
                    edgePoints[1] = [waypoints[i + 1].lat, waypoints[i + 1].lon];
                    var segmentLength = distanceInMiles(waypoints[i].lat,
                        waypoints[i].lon,
                        waypoints[i + 1].lat,
                        waypoints[i + 1].lon);
                    totalMiles += segmentLength;
                    var color = unclinchedColor;
                    var opacity = 0.3;
                    if (segments[nextSegment] == clinched[nextClinchedCheck]) {
                        color = clinchedColor;
                        nextClinchedCheck++;
                        clinchedMiles += segmentLength;
                        opacity = 0.85;
                    }
                    connections[nextSegment] = L.polyline(edgePoints, {
                        color: color,
                        weight: weight,
                        opacity: opacity
                    }).addTo(map);
                    edgeListener(nextSegment);
                    nextSegment++;
                }
            }
            // set up listener for changes to zoom level and adjust
            // weight in response
            map.on('zoomend', zoomChange);
            zoomChange();
        }
        else {
            // single route
            for (var i = 0; i < segments.length; i++) {
                var edgePoints = new Array(2);
                edgePoints[0] = [waypoints[i].lat, waypoints[i].lon];
                edgePoints[1] = [waypoints[i + 1].lat, waypoints[i + 1].lon];
                var segmentLength = distanceInMiles(waypoints[i].lat,
                    waypoints[i].lon,
                    waypoints[i + 1].lat,
                    waypoints[i + 1].lon);
                totalMiles += segmentLength;
                var color = "#cccccc";
                if (segments[i] == clinched[nextClinchedCheck]) {
                    color = "#ff8080";
                    nextClinchedCheck++;
                    clinchedMiles += segmentLength;
                }
                connections[i] = L.polyline(edgePoints, {
                    color: color,
                    weight: 10,
                    opacity: 0.75
                }).addTo(map);
                edgeListener(i);
            }
        }
        if (document.getElementById('controlboxinfo') != null) {
            document.getElementById('controlboxinfo').innerHTML = ""; //clinchedMiles.toFixed(2) + " of " + totalMiles.toFixed(2) + " miles (" + (clinchedMiles/totalMiles*100).toFixed(1) + "%) clinched by " + traveler + ".";
        }
    }
    else if (genEdges) {
        connections[0] = L.polyline(polypoints, {
            color: "#0000FF",
            weight: 10,
            opacity: 0.75
        }).addTo(map);
        connections[0].on('click', function () {
            edgeClick(0);
        });
    }
    // don't think this should not be needed, but an attempt to get
    // hidden waypoints to be hidden when first created
    showHiddenClicked();
}

// find a color to use to draw an edge in a graph, where colors represent
// the number of concurrent routes on a segment
function getGraphEdgeColor(edge) {
    // count the commas, which tell us how many concurrent routes are
    // represented, as they will be comma-separated, then use that to
    // choose a color to indicate the number of routes following the
    // edge
    concurrent = edge.label.split(",").length;
    color = "";
    switch (concurrent) {
        case 1:
            color = "#0000FF";
            break;
        case 2:
            color = "#00FF00";
            break;
        case 3:
            color = "#FF00FF";
            break;
        case 4:
            color = "#FFFF00";
            break;
        default:
            color = "#FF0000";
            break;
    }
    return color;
}

function zoomChange() {

    var level = map.getZoom();
    var newWeight;
    if (level < 9) newWeight = 2;
    else if (level < 12) newWeight = 6;
    else if (level < 15) newWeight = 10;
    else newWeight = 16;
    for (var i = 0; i < connections.length; i++) {
        connections[i].setStyle({weight: newWeight});
    }
}

// variable that would be set by any code that wishes to register
// an additional function to be called on a marker click
var labelClickCallback = null;

// set that variable
function registerMarkerClickListener(func) {

    labelClickCallback = func;
}

function addMarker(marker, markerinfo, i) {

    marker.addTo(map);
    marker.bindPopup(markerinfo);
    marker.on('click', function () {
        if (labelClickCallback != null) {
            labelClickCallback(i);
        }
    });
}

// note: there is also a labelClickHDX used when selecting start and
// end vertices for HDX algorithm visualizations
// this one is only called by the HB when someone clicks on
// a waypoint in the table (not on the map)
function labelClick(i, label, lat, lon, errors) {

    map.panTo([lat, lon]);
}

// handle clicks on edges
function edgeClick(i) {

    var v1 = waypoints[graphEdges[i].v1];
    var v2 = waypoints[graphEdges[i].v2];
    var midlat = (parseFloat(v1.lat) + parseFloat(v2.lat)) / 2.0;
    var midlon = (parseFloat(v1.lon) + parseFloat(v2.lon)) / 2.0;
    map.panTo([midlat, midlon]);
}

function markerInfo(i, wpt) {

    var intersections = "";
    if (wpt.hasOwnProperty('intersecting')) {
        intersections = "<p>Intersecting/Concurrent Routes:<br />";
        for (var j = 0; j < wpt.intersecting.length; j++) {
            r = wpt.intersecting[j];
            intersections += "<a href=\"/routes/" + r.root + "\">" + r.region + " " + r.route + " " + r.banner;
            if (r.city != "") {
                intersections += "(" + r.city + ")";
            }
            intersections += "</a><br />";
        }
        intersections += "</p>";
    }
    return '<p style="line-height:160%;"><span style="font-size:24pt;color:black;">' + wpt.label + '</span><br><b>Waypoint '
        + i + '<\/b><br><b><a target="_blank" href="http://www.openstreetmap.org/?lat=' + wpt.lat + '&lon=' + wpt.lon +
        '">Coords.:<\a><\/b> ' + wpt.lat + '&deg;, ' + wpt.lon + '&deg;<\/p>' + intersections;

}

function edgeInfo(i) {

    return '<p style="line-height:160%;"><span style="font-size:24pt; color:black">' +
        graphEdges[i].label + '</span><br><b>Edge Number: ' + (i) +
        '<\/b><br><b>Endpoints:<\/b> ' +
        waypoints[graphEdges[i].v1].label + ' <-> ' +
        waypoints[graphEdges[i].v2].label +
        '<br><b>Distance: </b>' +
        edgeLengthInMiles(graphEdges[i]).toFixed(4) + ' mi</p>';
}


// compute the length of an edge in miles
function edgeLengthInMiles(e) {

    if (!e.hasOwnProperty("length")) {
        let len = 0.0;
        if (e.via == null) {
            // no intermediate points: easy case
            len = distanceInMiles(waypoints[e.v1].lat, waypoints[e.v1].lon,
                waypoints[e.v2].lat, waypoints[e.v2].lon);
        }
        else {
            // account for intermediate points in "via" array
            len = distanceInMiles(waypoints[e.v1].lat, waypoints[e.v1].lon,
                parseFloat(e.via[0]), parseFloat(e.via[1]));
            for (var pos = 0; pos < e.via.length - 2; pos += 2) {
                len += distanceInMiles(parseFloat(e.via[pos]),
                    parseFloat(e.via[pos + 1]),
                    parseFloat(e.via[pos + 2]),
                    parseFloat(e.via[pos + 3]));
            }
            len += distanceInMiles(parseFloat(e.via[e.via.length - 2]),
                parseFloat(e.via[e.via.length - 1]),
                waypoints[e.v2].lat, waypoints[e.v2].lon);
        }
        e.length = len;
    }
    return e.length;
}

// compute distance in miles between two lat/lon points
function distanceInMiles(lat1, lon1, lat2, lon2) {
    if (lat1 == lat2 && lon1 == lon2)
        return 0.;

    var rad = 3963.;
    var deg2rad = Math.PI / 180.;
    var ang = Math.cos(lat1 * deg2rad) * Math.cos(lat2 * deg2rad) * Math.cos((lon1 - lon2) * deg2rad) + Math.sin(lat1 * deg2rad) * Math.sin(lat2 * deg2rad);
    return Math.acos(ang) * 1.02112 * rad;
}

// compute distance in feet between two lat/lon points
function distanceInFeet(lat1, lon1, lat2, lon2) {
    if (lat1 == lat2 && lon1 == lon2)
        return 0.;

    var rad = 3963.;
    var deg2rad = Math.PI / 180.;
    var ang = Math.cos(lat1 * deg2rad) * Math.cos(lat2 * deg2rad) * Math.cos((lon1 - lon2) * deg2rad) + Math.sin(lat1 * deg2rad) * Math.sin(lat2 * deg2rad);
    return Math.acos(ang) * 1.02112 * rad * 5280;
}

// callback for when the showHidden checkbox is clicked
function showHiddenClicked() {

    var showHidden = false;
    if (document.getElementById('showHidden') != null) {
        showHidden = document.getElementById('showHidden').checked;
    }
    if (showHidden) {
        // add in the hidden markers
        for (var i = 0; i < waypoints.length; i++) {
            if (!waypoints[i].visible) {
                addMarker(markers[i], markerinfo[i], i);
            }
        }
    }
    else {
        // hide the ones that should no longer be visible
        for (var i = 0; i < waypoints.length; i++) {
            if (!waypoints[i].visible) {
                markers[i].remove();
            }
        }
    }
}

// GraphEdge constructor, vertex numbers can come in as strings or
// numbers, will store as numbers
function GraphEdge(v1, v2, label, via) {

    if (typeof v1 === 'string') {
        this.v1 = parseInt(v1);
        this.v2 = parseInt(v2);
    }
    else {
        this.v1 = v1;
        this.v2 = v2;
    }
    this.label = label;
    this.via = via;

    return this;
}

// callback for when the hideMarkers checkbox is clicked
function showMarkersClicked() {

    var showThem = document.getElementById('showMarkers').checked;
    if (showThem) {
        for (var i = 0; i < waypoints.length; i++) {
            if (waypoints[i].visible) {
                addMarker(markers[i], markerinfo[i], i);
            }
        }
    }
    else {
        for (var i = 0; i < waypoints.length; i++) {
            markers[i].remove();
        }
    }
}

// listen for clicks on edges
function edgeListener(i) {
    connections[i].on('click',
        function (e) {
            edgeClick(i);
        });
    //connections[i].bindPopup(edgeInfo(i));
}

function redirect(url) {
    var win = window.open(url);
    win.focus();
}

// JS debug window by Mike Maddox from
// http://javascript-today.blogspot.com/2008/07/how-about-quick-debug-output-window.html
var DBG = {
    write: function (txt) {
        if (!window.dbgwnd) {
            window.dbgwnd = window.open("", "debug", "status=0,toolbar=0,location=0,menubar=0,directories=0,resizable=0,scrollbars=1,width=600,height=250");
            window.dbgwnd.document.write('<html><head></head><body style="background-color:black"><div id="main" style="color:green;font-size:12px;font-family:Courier New;"></div></body></html>');
        }
        var x = window.dbgwnd.document.getElementById("main");
        this.line = (this.line == null) ? 1 : this.line += 1;
        txt = this.line + ': ' + txt;
        if (x.innerHTML == "") {
            x.innerHTML = txt;
        }
        else {
            x.innerHTML = txt + "<br/>" + x.innerHTML;
        }
    }
}
